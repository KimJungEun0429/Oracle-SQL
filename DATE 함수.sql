--DATATYPE DATE

SELECT SYSDATE FROM DUAL;

CREATE TABLE DATE_TEST
(
    NAME        VARCHAR2(30)    NOT NULL,
    INDATE      DATE            NOT NULL
);

INSERT INTO DATE_TEST VALUES('홍길동', SYSDATE);
INSERT INTO DATE_TEST VALUES('전우치', '2021-04-11');
INSERT INTO DATE_TEST VALUES('김갑돌', '2021-04-10');

--COMMIT;

SELECT * FROM DATE_TEST;

--1. DATE - TO_CHAR
SELECT NAME, TO_CHAR(INDATE, 'MM-DD-YYYY HH:MI:SS') 
FROM DATE_TEST;

--2. DATE TYPE 원리 - ORACLE --> 숫자
--DATE타입은 숫자다
SELECT SYSDATE - 30 FROM DUAL;

SELECT INDATE, TO_CHAR(INDATE - 5, 'MM-DD-YYYY HH:MI:SS')  
FROM DATE_TEST;
--날짜 데이터를 입력할 때 시분초를 따로 주지 않으면 12:00:00을 기준으로 들어가게 된다.
--날짜의 구동원리는 숫자다

--1.년
SELECT INDATE, TO_CHAR(INDATE, 'YY') AS INYEAR FROM DATE_TEST;

SELECT INDATE, TO_CHAR(INDATE, 'MM') AS INMONTH FROM DATE_TEST;

--2021년 4월 12일이라고 해달라고 하면?
--구글에 가서 날짜함수 중에 04가 아니라 4라고 표현이 되는지 찾아보기(왜냐하면 버전마다 다르기 때문)
SELECT INDATE, TO_CHAR(INDATE, 'DL') AS IND FROM DATE_TEST;

--요일
SELECT INDATE, TO_CHAR(INDATE, 'D') AS INWEEK FROM DATE_TEST;
--월요일이 숫자 2로 나왔다 - 일요일부터 1이다
SELECT INDATE, TO_CHAR(INDATE, 'DAY'), TO_CHAR(INDATE, 'D')-1 AS INWEEK FROM DATE_TEST;
--요일을 숫자값으로 계산을 하고 싶을 때 사용한다. 일요일부터 1이라는 것을 기억하기. 일요일을 0부터 시작하고 싶으면 -1해주면 된다.

------

SELECT INDATE, TO_CHAR(INDATE, 'YEAR') FROM DATE_TEST;
SELECT INDATE, TO_CHAR(INDATE, 'YYYY') || '년' FROM DATE_TEST;

--2021년 4월 1일부터 4월 30일까지 날짜를 모두 표시하고 출석횟수를 표시하시오.

SELECT LEVEL, INDATE 
FROM DATE_TEST
CONNECT BY LEVEL < 3
;
--LEVEL은 내가 만들고 싶은 ROW 갯수

SELECT * FROM DATE_TEST;

SELECT SYSDATE, LEVEL, SYSDATE - LEVEL FROM DUAL
CONNECT BY LEVEL < 12
;

SELECT TO_DATE('2021-04-01'), LEVEL, TO_DATE('2021-04-01') + (LEVEL-1) FROM DUAL
CONNECT BY LEVEL < 31
;
--TO_DATE는 데이트 타입으로 바꿔줌

SELECT TO_DATE('2021-04-01') + (LEVEL-1) AS MONTH_DATE FROM DUAL
CONNECT BY LEVEL < 30
;

SELECT LEVEL FROM DUAL
CONNECT BY LEVEL <= 10
;

SELECT SYSDATE +1 FROM DUAL;

SELECT TO_CHAR(TO_DATE('2021-04-01') + (LEVEL-1), 'YYYY-MM-DD') INDATE 
FROM DUAL
CONNECT BY LEVEL < 30
;

INSERT INTO DATE_TEST VALUES('전우치', '2021-04-11');

SELECT * FROM DATE_TEST;


--ROLLBACK;

SELECT TO_CHAR(INDATE, 'YYYY-MM-DD'), COUNT(*)
FROM DATE_TEST
GROUP BY TO_CHAR(INDATE, 'YYYY-MM-DD')
;
--이렇게 데이터타입을 바꾸라고 주는 이유는 시분초가 다르면 다른 데이터로 카운터가 되기 때문에

SELECT '안녕', LEVEL FROM DUAL
CONNECT BY LEVEL <= 10
;
--10개의 ROW를 만들자

SELECT SYSDATE, LEVEL FROM DUAL
CONNECT BY LEVEL <= 10
;

SELECT TO_DATE('2021-04-01'), (LEVEL -1) 
, TO_DATE('2021-04-01') + (LEVEL -1) 
FROM DUAL
CONNECT BY LEVEL <= 30
;

SELECT TO_DATE('2021-04-01') + (LEVEL -1) AS MDATE
FROM DUAL
CONNECT BY LEVEL <= 30
;

SELECT * FROM DATE_TEST;

SELECT T1.MDATE, COUNT(T2.INDATE) FROM 
(
SELECT TO_DATE('2021-04-01') + (LEVEL -1) AS MDATE
FROM DUAL
CONNECT BY LEVEL <= 30
)T1, DATE_TEST T2
WHERE TO_CHAR(T1.MDATE, 'YYYYMMDD') =  TO_CHAR(T2.INDATE(+),'YYYYMMDD')
GROUP BY MDATE
ORDER BY T1.MDATE
;
--ORDER BY 래프트 조인이 걸린 중심을 찾아서 걸어주기 T1.MDATE를 기준으로 걸었으니까!

-- SYSDTE 예제
SELECT TO_CHAR(SYSDATE,'RRRR-MM-DD HH24:MI:SS') "지금시간"
  FROM DUAL ;
 
SELECT TO_CHAR(SYSDATE-1,'RRRR-MM-DD HH24:MI:SS') "하루전지금시간"
  FROM DUAL ;
 
SELECT TO_CHAR(SYSDATE-1/24,'RRRR-MM-DD HH24:MI:SS') "1시간전시간"
  FROM DUAL ;
 
SELECT TO_CHAR(SYSDATE-1/24/60,'RRRR-MM-DD HH24:MI:SS') "1분전시간"
  FROM DUAL ;
 
SELECT TO_CHAR(SYSDATE-1/24/60/10,'RRRR-MM-DD HH24:MI:SS') "6초전시간"
  FROM DUAL ;
  
  SELECT TO_CHAR(SYSDATE-1/(24 * 60 * 60),'RRRR-MM-DD HH24:MI:SS')
  FROM DUAL ;
 
SELECT TO_CHAR(SYSDATE-(5/24 + 30/24/60 + 10/24/60/60),'RRRR-MM-DD HH24:MI:SS') "5시간 30분 10초전"
 FROM DUAL ;
 
 SELECT SYSTIMESTAMP FROM DUAL;
 --1초를 10억분의 1로 나눈것
 
 SELECT ADD_MONTHS(SYSDATE, -5) FROM DUAL;
  
 
 
 SELECT MONTHS_BETWEEN(SYSDATE, SYSDATE + 10) FROM DUAL;
 --앞에서 뒤로 빼는 것

SELECT T1.MDATE, COUNT(T2.INDATE) FROM 
(
SELECT TO_DATE('2021-04-01') + (LEVEL -1) AS MDATE
FROM DUAL
CONNECT BY LEVEL <= TO_CHAR(LAST_DAY(TO_DATE('2021-04-01')),'DD')
)T1, DATE_TEST T2
WHERE TO_CHAR(T1.MDATE, 'YYYYMMDD') =  TO_CHAR(T2.INDATE(+),'YYYYMMDD')
GROUP BY MDATE
ORDER BY T1.MDATE
;

SELECT LAST_DAY(TO_DATE('2021-04-01')) FROM DUAL;
SELECT TO_NUMBER(TO_CHAR(LAST_DAY(TO_DATE('2021-04-01')),'DD')) FROM DUAL;

SELECT TO_DATE('2021-04-01') + (LEVEL -1) AS MDATE
FROM DUAL
CONNECT BY LEVEL <= TO_NUMBER(TO_CHAR(LAST_DAY(TO_DATE('2021-04-01')),'DD'))
;
--진짜 많이 쓰는 코딩이니까 기억해놓기

SELECT NEXT_DAY(SYSDATE, 1) FROM DUAL;
--넣어주는 숫자는 요일을 뜻한다. 오늘을 기준으로 다음에 올 일요일을 찾아라!

SELECT T1.MDATE, COUNT(T2.INDATE) FROM 
(
SELECT TO_DATE('2021-04-01') + (LEVEL -1) AS MDATE
FROM DUAL
CONNECT BY LEVEL <= 30
)T1, DATE_TEST T2
WHERE TO_CHAR(T1.MDATE, 'YYYYMMDD') =  TO_CHAR(T2.INDATE(+),'YYYYMMDD')
GROUP BY MDATE
ORDER BY T1.MDATE
;

--2021년 1월부터 2021년 12월까지를 잡자
SELECT TO_CHAR(T1.MDATE,'YYYYMM'), COUNT(T2.INDATE) FROM
(
SELECT ADD_MONTHS(TO_DATE('2021-01-01'), LEVEL-1)AS MDATE 
FROM DUAL CONNECT BY LEVEL<= 12
)T1, DATE_TEST T2
WHERE TO_CHAR(T1.MDATE,'YYYYMM') = TO_CHAR(T2.INDATE(+),'YYYYMM')
GROUP BY TO_CHAR(T1.MDATE,'YYYYMM')
ORDER BY TO_CHAR(T1.MDATE,'YYYYMM')
;

--------------------------------------------------------
SELECT TO_CHAR(TO_DATE('2021-01-01'),'YYYY-MM') + (LEVEL-1) AS MDATE
FROM DUAL
CONNECT BY LEVEL <= 12
;
--이렇게 짜버리면 2021-01-01 날짜 형식을 yyyy-mm으로 바꿔주세요가 되서 문자열에 (LEVEL-1)을 더하게 됨

SELECT TO_CHAR(TO_DATE('2021-01-01')+ (LEVEL-1),'YYYY-MM')  AS MDATE
FROM DUAL
CONNECT BY LEVEL <= 12
;
--그래서 순서를 이렇게 줘야하는데 이렇게 하면 DAY에다가 LEVER을 더하게됨. MONTH에 더하고 싶어서 TO_DATE의 DAY를 빼버리면 TO_DATE가 읽히지 않음
--TO_DATE는 DAY까지 써줘야함 고로 ADD_MONTHS를 쓰는 것이 좋다.

SELECT TO_CHAR(TO_DATE('2021-01-01'),'YYYYMM') + (LEVEL-1) AS MDATE
FROM DUAL
CONNECT BY LEVEL <= 12
;
--이렇게 짜면 얘가 또 계산을 하는데 YYYYMM얘를 지가 지레짐작으로 숫자겠거니 하면서 계산을 해버리는거라 결과가 나오면 안됨
-----------------------------------------------------------

SELECT TO_DATE('2021-01-01') AS MDATE FROM DUAL;

SELECT TO_CHAR(ADD_MONTHS(TO_DATE('2021-01-01'), LEVEL-1),'YYYY-MM')AS MDATE 
FROM DUAL CONNECT BY LEVEL<= 12
;

